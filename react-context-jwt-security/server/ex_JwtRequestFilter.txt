

----- JwtRequestFilter.java에서 filterChain.doFilter 에러 발생 -----


/*
 * jwt 토큰이 넘어왔을 때 작동해야하는 필터
 * -> 토큰을 해석하는 역할의 필터
 * OncePerRequestFilter : 한 요청당 한 번만 실행되는 필터
 */

 @Slf4j
public class JwtRequestFilter extends OncePerRequestFilter implements Filter {
   
   private JwtTokenProvider jwtTokenProvider;

   //생성자
   public JwtRequestFilter(JwtTokenProvider jwtTokenProvider){
      this.jwtTokenProvider = jwtTokenProvider;
   }

   /*
   jwt 요청 필터
      - request > headers > Authorization에 들었는 토큰을 꺼낸다
      - jwt 토큰 유효성 검사
   */
   @Override
   protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain){  

     
      //헤더에서 jwt 토큰을 가져옴
      String header = request.getHeader(JwtConstants.TOKEN_HEADER);
      log.info("authorization : " + header);

      //Bearer + {jwt} 체크
      if( header == null || header.length() == 0 || !header.startsWith(JwtConstants.TOKEN_PREFIX)){
         
         //토큰이 존재하지 않는다 -> 다음 필터로 넘긴다
         
         //filterChain.doFilter : 이 메서드를 호출하면 현재 필터를 포함하여 필터 체인에 등록된 모든 필터들이 순서대로 실행되도록 합니다.

         //filterChain.doFilter(request, response); //----------- error
         return;
      }
      
      /*
       * 클라이언트 요청 -------> jwtRequest 필터 -------> jwtAuth 필터
       * 토큰이 없는 경우 jwtRequest에서 jwtAut필터로 넘긴다
       * 이 경우는 로그인을 요청한 경우로 로그인시 두 필터를 다 넘긴다
       */
      //jwt
      //Bearer + {jwt} = "Bearar" 
      String jwt = header.replace(JwtConstants.TOKEN_PREFIX, "");

      //토큰 해석
      Authentication authentication = jwtTokenProvider.getAuthentication(jwt);

      //토큰 유효성 검사
      if(jwtTokenProvider.validateToken(jwt)){
         log.info("유효한 JWT 토큰입니다");

         //로그인
         SecurityContextHolder.getContext().setAuthentication(authentication);
      }

      //다음 필터
      //chain.doFilter(request, response); //----------- error
   }
   

}
